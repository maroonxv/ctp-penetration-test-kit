# “真断线”穿透测试方案（直接杀掉 Worker 进程）

## 1. 目的

在 CTP 穿透测试中，“断线”不是指应用层把某个对象置空或逻辑上认为已断开，而是要让**交易所/柜台/前置系统能够客观记录到：该会话的网络连接确实断开**（例如前置断开、会话掉线、心跳超时、连接重置等）。

本方案目标：

- 让对端能查到“确实断线”的证据（可验收）
- 断线过程中 Web 控制台不受影响、持续可用（可操作、可留痕）
- 断线后可恢复：重启 Worker → 重新登录 → 继续执行后续测试

## 2. 为什么必须“杀 Worker”才算真断线

在 VnPy/CTP 网关实现中，很多“断线”动作本质上是：

- 逻辑层解除引用、移除网关对象、停止向网关发请求
- 或调用某些 API 但底层 CTP C++ 扩展存在阻塞/死锁风险，导致无法可靠 close

这类动作**不能保证对端看到 TCP 会话真实断开**，因为：

- 底层 socket 可能仍保持打开
- 对端只能基于网络层/会话层事件判断是否掉线

要让对端必然可见，最可靠的方法是：

- **让持有该 socket 的进程退出**
- 由操作系统回收资源并关闭连接（强制 FIN/RST/超时断开，取决于当时状态）

因此，“进程分离”的价值在这里体现为：Web 作为 Supervisor 直接杀 Worker，就能实现可验收的“真断线”，且不会卡死 Web。

## 3. 方案前提（架构）

### 3.1 角色划分

- Web/Master：负责 UI、API、日志展示、以及 Worker 生命周期管理（启动/重启/强杀）
- Worker/Trader：负责 CTP 连接、执行用例、产生日志与状态，并回传给 Web

### 3.2 关键动作的责任边界

- “断线动作（真断线）”必须由 Web 执行：`kill_worker()`
- Worker 只负责“启动后重新连接/重新登录/继续执行”

原因很简单：Worker 一旦自杀，就无法继续汇报和恢复；Supervisor 才能保证闭环。

## 4. 执行思路（完整闭环）

### 4.1 时间线与证据点

建议按以下三段时间戳组织证据：

- T1：确认已连接且对端可识别（会话存在）
- T2：执行 kill（真断线发生）
- T3：重启并重新登录成功（新会话恢复）

你需要同时保留：

- 本地日志（Web/Worker 日志，带时间戳）
- 对端日志/柜台查询结果（带时间戳）

### 4.2 执行步骤

#### 步骤 1：建立“可识别的在线会话”（T1）

目的：让对端明确“这个会话在断线前确实存在并处于在线状态”，方便之后对比断线事件。

操作建议（任选其一或组合）：

- 等待登录成功相关日志出现（例如 OnFrontConnected/登录成功/查询成功等）
- 主动发起一次查询（如 query_account），确认通信链路可用
- 可选：发出一笔极小、风控允许的请求（更强证据，但注意风险）

验收标准：

- 本地日志显示已连接/已登录/查询有回包
- 对端能查到该会话处于在线或近期有请求交互

#### 步骤 2：执行“真断线”（T2）

核心动作：**直接杀掉 Worker 进程**。

伪代码（Supervisor 侧）：

```
if worker_process_running:
    kill(worker_process)   # OS 级别强制终止
record_timestamp(T2)
```

操作要点：

- kill 必须作用于真正持有 CTP 连接的进程（Worker），而不是 Web
- kill 后 Web 仍应保持可用，用于记录与展示

#### 步骤 3：给对端留出“判定掉线窗口”

对端识别掉线通常依赖：

- TCP 断开/重置事件（可能立刻发生）
- 心跳/会话超时（可能延迟数秒到数十秒）

建议：

- kill 后至少等待 5–30 秒（以你柜台心跳/超时策略为准）
- 以“对端日志出现断线/掉线记录”为最终判定

#### 步骤 4：恢复（T3：重启 Worker 并重新登录）

伪代码（Supervisor 侧）：

```
start(worker_process)
wait_until(worker_ready && login_success)
record_timestamp(T3)
```

验收标准：

- Worker 新进程启动（PID/启动日志可区分）
- 出现新一轮连接/登录成功日志（而不是旧对象复用）
- Web 继续能接收 Worker 日志与状态

#### 步骤 5：完成“可验收证据闭环”

你需要能在报告中明确写清：

- T1：在线证据（本地 + 对端）
- T2：kill 动作（本地）与断线记录（对端）
- T3：恢复成功（本地 + 对端）

如果对端提供会话编号/登录编号等字段，建议在断线前后分别记录，证明是两次会话而非同会话抖动。

## 5. 如何在当前控制台里执行

当前工程已提供 Worker 生命周期 API（由 Web 执行）：

- `POST /api/worker/kill`：强制终止 Worker（真断线）
- `POST /api/worker/restart`：重启 Worker（恢复）
- `GET /api/worker/status`：查看 Worker 状态（辅助）

### 5.1 一键执行（推荐）

目标：在前端点击“2.2.1 连接状态监测”按钮时，自动完成真断线闭环（T1/T2/T3），并将关键时间点以日志形式输出到前端与文件日志中，便于直接用于穿透测试材料整理。

行为约定：

- 前端按钮仍然调用既有的 `POST /api/run/2.2.1`
- Web 检测到 `case_id == 2.2.1` 后，不转发给 Worker 的 `RUN_CASE`，而是由 Web 自己作为 Supervisor 执行“硬断线编排”
- 编排步骤中产生的关键日志由 Web 直接推送到前端（同时 Worker 的重启/重连日志也会回传展示）

伪代码（Web 编排逻辑）：

```
emit("T1: 确认 Worker 就绪")
ensure_worker_running()
wait_ping_ok(timeout=10)

emit("T2: kill Worker（真断线）")
kill_worker()
sleep(disconnect_window_s)

emit("T3: 启动 Worker（恢复）")
start_worker()
wait_ping_ok(timeout=60)
```

验收标准：

- 对端能在 T2±窗口内看到会话断开/掉线记录
- 对端能在 T3 附近看到新的连接/登录记录
- 前端日志中能看到 T1/T2/T3 三个时间点与过程记录

### 5.2 手动执行（备用）

当你需要独立验证或排障时，可以直接使用 API 手动操作。

建议执行顺序：

- 先进入 Web 控制台并确认日志在滚动（表明 Worker 正常回传）
- 先完成“在线证据”（T1）
- 调用 `/api/worker/kill` 并记录时间（T2）
- 等待对端判定窗口
- 调用 `/api/worker/restart`，观察重新登录成功并记录时间（T3）

## 6. 与“软断线/软重连”的关系

软断线通常指在 Worker 内部调用某些逻辑动作（如移除网关引用、触发 reconnect），这类动作的价值在于：

- 验证系统内部的异常监测、状态切换、重连流程是否健全

但软断线**不适合作为穿透测试的断线证据**，因为对端不一定会记录为“会话真实掉线”。

建议将测试项拆分成两类输出：

- “2.2.1（软）连接状态监测”：用于功能自测
- “2.2.1（硬）真断线监测”：用于穿透测试可验收材料（本方案）

## 7. 注意事项（避免踩坑）

### 7.1 端口与重启稳定性

- Worker 被 kill 后，RPC 端口（如 9999）可能需要短暂时间释放；重启前可等待 200ms–2s
- 如果重启失败，优先排查端口占用、残留进程、以及启动工作目录/环境变量（PYTHONPATH）

### 7.2 “断线可见”的延迟

对端“看见断线”的时间不一定与 kill 时间完全一致，常见原因：

- 对端以心跳超时判定掉线
- 网络栈/中间链路对断开事件的传播存在延迟

穿透测试报告中应以对端日志时间为准，说明本地 kill 时间与对端判定时间的对应关系。

### 7.3 风险与合规

- 在进行真断线前，尽量保证账户无未完成关键委托（或清楚记录当前委托状态），避免因断线带来不可预期风险
- 真断线后第一时间验证恢复流程，并确认资金/持仓/委托状态与预期一致

## 8. 最小检查清单（执行时照着打勾）

- 已看到连接/登录成功相关日志（T1）
- 已在对端确认会话在线或近期有请求（T1）
- 已执行 kill Worker 并记录时间（T2）
- 对端已出现会话断开/掉线记录（T2±窗口）
- 已重启 Worker 并看到新连接/新登录成功（T3）
- 对端已出现新的连接/登录记录（T3）
- 恢复后能继续执行后续测试项，Web 日志正常持续展示
